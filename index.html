<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Finnish Train Tracker (Simulation)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      /* Base styles */
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f2f5;
        color: #333;
      }

      /* Modern container with subtle gradient background */
      .container {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: linear-gradient(to bottom, #f8f9fa, #e9ecef);
      }

      /* Enhanced header with depth and modern styling */
      .header {
        background: linear-gradient(135deg, #005cbf 0%, #0053a0 100%);
        color: white;
        padding: 12px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .header h1 {
        margin: 0;
        font-size: 1.6rem;
        font-weight: 600;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      /* Main content container */
      .content-container {
        display: flex;
        flex-direction: column;
        flex: 1;
        height: calc(100% - 60px);
      }

      /* Map container with improved styling */
      .map-container {
        flex: 3;
        position: relative;
        min-height: 60%;
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        border-bottom: 1px solid #ddd;
      }

      /* Chart container with card-like styling */
      .chart-container {
        flex: 2;
        position: relative;
        padding: 15px;
        background-color: white;
        border-top: 1px solid #ddd;
        min-height: 200px;
        box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .chart-title {
        font-weight: 600;
        font-size: 1.1em;
        color: #0053a0;
      }

      .chart-controls {
        display: flex;
        gap: 10px;
      }

      #chartCanvas {
        width: 100%;
        height: 180px;
        border-radius: 4px;
      }

      #map {
        height: 100%;
        width: 100%;
      }

      /* Modern info panel with card styling */
      .info-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        padding: 15px;
        z-index: 1000;
        max-width: 320px;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }

      .info-panel h3 {
        margin-top: 0;
        margin-bottom: 12px;
        color: #0053a0;
        border-bottom: 2px solid #e6e6e6;
        padding-bottom: 8px;
      }

      /* Enhanced train info cards */
      .train-info {
        margin-bottom: 12px;
        padding: 10px;
        border-radius: 6px;
        background-color: #f8f9fa;
        border-left: 4px solid #0053a0;
        transition: all 0.2s ease;
      }

      .train-info:hover {
        background-color: #e9ecef;
        transform: translateX(2px);
      }

      .train-info:last-child {
        margin-bottom: 0;
      }

      .train-type {
        font-weight: bold;
        color: #0053a0;
        display: flex;
        justify-content: space-between;
      }

      .stats {
        margin-top: 6px;
        font-size: 0.9em;
        color: #666;
      }

      /* Modern controls with improved styling */
      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      /* Glowing button styles */
      button {
        background: linear-gradient(to bottom, #0066cc, #004080);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.3s ease;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
      }

      button:hover {
        background: linear-gradient(to bottom, #0077e6, #005cb3);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      button:active {
        transform: translateY(1px);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      /* Glowing effect for tracking buttons */
      #startTracking,
      #stopTracking {
        position: relative;
        z-index: 1;
      }

      #startTracking {
        background: linear-gradient(to bottom, #00b300, #008000);
        animation: pulse-green 2s infinite;
      }

      #startTracking:hover {
        background: linear-gradient(to bottom, #00cc00, #009900);
      }

      #stopTracking {
        background: linear-gradient(to bottom, #cc0000, #990000);
        animation: pulse-red 2s infinite;
        display: none;
      }

      #stopTracking:hover {
        background: linear-gradient(to bottom, #ff0000, #cc0000);
      }

      @keyframes pulse-green {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 179, 0, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 179, 0, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 179, 0, 0);
        }
      }

      @keyframes pulse-red {
        0% {
          box-shadow: 0 0 0 0 rgba(204, 0, 0, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(204, 0, 0, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(204, 0, 0, 0);
        }
      }

      /* Status indicator with improved styling */
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: rgba(255, 255, 255, 0.2);
        padding: 6px 12px;
        border-radius: 20px;
      }

      .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #cccccc;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
      }

      .status-indicator.active {
        background-color: #00cc00;
        box-shadow: 0 0 8px rgba(0, 204, 0, 0.6);
      }

      .status-text {
        font-size: 0.9em;
        font-weight: 500;
      }

      .train-count {
        font-weight: bold;
        margin-left: 15px;
        background-color: rgba(0, 0, 0, 0.1);
        padding: 3px 8px;
        border-radius: 12px;
      }

      /* Enhanced panels with modern styling */
      .settings-panel,
      .legend-panel {
        background-color: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        position: absolute;
        left: 10px;
        z-index: 1000;
        border: 1px solid rgba(0, 0, 0, 0.05);
        transition: all 0.3s ease;
      }

      .settings-panel {
        top: 10px;
      }

      .legend-panel {
        bottom: 30px;
      }

      .legend-title {
        font-weight: bold;
        margin-bottom: 10px;
        text-align: center;
        color: #0053a0;
        border-bottom: 2px solid #e6e6e6;
        padding-bottom: 5px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        padding: 4px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
      }

      .legend-item:hover {
        background-color: #f0f0f0;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 10px;
        border: 1px solid #333;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .settings-title {
        font-weight: bold;
        margin-bottom: 12px;
        color: #0053a0;
        border-bottom: 2px solid #e6e6e6;
        padding-bottom: 5px;
      }

      .settings-grid {
        display: grid;
        grid-template-columns: auto auto;
        gap: 10px;
        align-items: center;
      }

      .settings-label {
        font-size: 0.9em;
        color: #555;
      }

      /* Enhanced form controls */
      input[type="range"] {
        width: 100%;
        height: 6px;
        -webkit-appearance: none;
        background: #ddd;
        border-radius: 3px;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0053a0;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #0066cc;
        box-shadow: 0 0 5px rgba(0, 102, 204, 0.5);
      }

      input[type="number"] {
        width: 60px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
        text-align: center;
        transition: all 0.2s ease;
      }

      input[type="number"]:focus {
        border-color: #0053a0;
        box-shadow: 0 0 5px rgba(0, 83, 160, 0.3);
        outline: none;
      }

      select {
        padding: 6px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: white;
        transition: all 0.2s ease;
      }

      select:focus {
        border-color: #0053a0;
        box-shadow: 0 0 5px rgba(0, 83, 160, 0.3);
        outline: none;
      }

      .mode-toggle {
        margin-top: 12px;
        width: 100%;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }

        .controls {
          width: 100%;
          justify-content: space-between;
        }

        .info-panel {
          max-width: 280px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Finnish Train Tracker (Simulation)</h1>
        <div class="controls">
          <div class="status">
            <div id="statusIndicator" class="status-indicator active"></div>
            <span id="statusText" class="status-text">Simulation running</span>
            <span id="trainCount" class="train-count">0 trains</span>
          </div>
          <button id="startTracking">Start Tracking</button>
          <button id="stopTracking">Stop Tracking</button>
          <button id="toggleSettings">Settings</button>
        </div>
      </div>
      <div class="content-container">
        <div class="map-container">
          <div id="map"></div>
          <div id="settingsPanel" class="settings-panel" style="display: none">
            <div class="settings-title">Simulation Settings</div>
            <div class="settings-grid">
              <div class="settings-label">Train Count:</div>
              <input
                type="number"
                id="trainCountInput"
                min="1"
                max="50"
                value="15"
              />

              <div class="settings-label">Min Speed (km/h):</div>
              <input
                type="number"
                id="minSpeedInput"
                min="0"
                max="200"
                value="60"
              />

              <div class="settings-label">Max Speed (km/h):</div>
              <input
                type="number"
                id="maxSpeedInput"
                min="0"
                max="200"
                value="160"
              />

              <div class="settings-label">Update Interval:</div>
              <input
                type="range"
                id="updateIntervalInput"
                min="500"
                max="5000"
                step="500"
                value="1000"
              />
              <div class="settings-label"></div>
              <div id="updateIntervalValue">1 second</div>
            </div>
            <button id="applySettings" class="mode-toggle">Apply</button>
            <button id="resetTrains" class="mode-toggle">Reset Trains</button>
          </div>
          <div id="infoPanel" class="info-panel">
            <h3>Active Trains</h3>
            <div id="trainList"></div>
          </div>

          <div id="legendPanel" class="legend-panel">
            <div class="legend-title">Train Types</div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #ff0000"></div>
              <div>Long-distance</div>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #00aa00"></div>
              <div>Commuter</div>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #0000ff"></div>
              <div>Cargo</div>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #aa00aa"></div>
              <div>Locomotive</div>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background-color: #aa6600"></div>
              <div>Shunting</div>
            </div>
          </div>
        </div>

        <div class="chart-container">
          <div class="chart-header">
            <div class="chart-title">Train Speed Analysis</div>
            <div class="chart-controls">
              <select id="chartTypeSelector">
                <option value="speed">Speed Over Time</option>
                <option value="count">Train Count by Type</option>
                <option value="distribution">Speed Distribution</option>
              </select>
            </div>
          </div>
          <canvas id="chartCanvas"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Initialize map centered on Finland
      const map = L.map("map").setView([62.2426, 25.7473], 6);

      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map);

      // Store train markers and data
      const trains = {};
      let isTracking = true;
      let lastUpdateTime = null;
      let updateCount = 0;

      // Simulation settings
      let settings = {
        trainCount: 15,
        minSpeed: 60, // km/h
        maxSpeed: 160, // km/h
        updateInterval: 1000, // ms
      };

      // DOM elements
      const statusIndicator = document.getElementById("statusIndicator");
      const statusText = document.getElementById("statusText");
      const trainCountEl = document.getElementById("trainCount");
      const startTrackingButton = document.getElementById("startTracking");
      const stopTrackingButton = document.getElementById("stopTracking");
      const trainList = document.getElementById("trainList");
      const settingsPanel = document.getElementById("settingsPanel");
      const toggleSettingsButton = document.getElementById("toggleSettings");
      const chartTypeSelector = document.getElementById("chartTypeSelector");

      // Settings inputs
      const trainCountInput = document.getElementById("trainCountInput");
      const minSpeedInput = document.getElementById("minSpeedInput");
      const maxSpeedInput = document.getElementById("maxSpeedInput");
      const updateIntervalInput = document.getElementById(
        "updateIntervalInput"
      );
      const updateIntervalValue = document.getElementById(
        "updateIntervalValue"
      );
      const applySettingsButton = document.getElementById("applySettings");
      const resetTrainsButton = document.getElementById("resetTrains");

      // Train type icons with different colors
      const trainIcons = {
        "Long-distance": createTrainIcon("#ff0000"), // Red
        Commuter: createTrainIcon("#00aa00"), // Green
        Cargo: createTrainIcon("#0000ff"), // Blue
        Locomotive: createTrainIcon("#aa00aa"), // Purple
        Shunting: createTrainIcon("#aa6600"), // Brown
      };

      // Train routes - major Finnish cities
      const routes = [
        {
          name: "Helsinki-Tampere",
          path: [
            [60.1699, 24.9384], // Helsinki
            [60.4518, 25.0401], // Kerava
            [60.5996, 25.1032], // Järvenpää
            [60.9929, 25.6649], // Lahti
            [61.4978, 23.761], // Tampere
          ],
        },
        {
          name: "Helsinki-Turku",
          path: [
            [60.1699, 24.9384], // Helsinki
            [60.2052, 24.6522], // Espoo
            [60.168, 24.9426], // Kirkkonummi
            [60.2178, 24.0132], // Karjaa
            [60.4518, 22.2666], // Turku
          ],
        },
        {
          name: "Tampere-Oulu",
          path: [
            [61.4978, 23.761], // Tampere
            [62.2426, 25.7473], // Jyväskylä
            [63.0851, 25.3464], // Saarijärvi
            [63.6768, 25.5541], // Pyhäjärvi
            [65.0121, 25.4651], // Oulu
          ],
        },
        {
          name: "Helsinki-Kouvola",
          path: [
            [60.1699, 24.9384], // Helsinki
            [60.3932, 25.6649], // Porvoo
            [60.8716, 26.45], // Kouvola
            [61.0583, 28.1861], // Lappeenranta
          ],
        },
        {
          name: "Kouvola-Kuopio",
          path: [
            [60.8716, 26.45], // Kouvola
            [61.2332, 27.861], // Mikkeli
            [62.8924, 27.6768], // Kuopio
          ],
        },
        {
          name: "Oulu-Rovaniemi",
          path: [
            [65.0121, 25.4651], // Oulu
            [65.7418, 24.5667], // Kemi
            [66.5039, 25.7294], // Rovaniemi
          ],
        },
      ];

      // Finnish station names for train destinations
      const stationNames = [
        "Helsinki",
        "Tampere",
        "Turku",
        "Oulu",
        "Rovaniemi",
        "Kuopio",
        "Jyväskylä",
        "Kouvola",
        "Lahti",
        "Vaasa",
        "Joensuu",
        "Seinäjoki",
        "Mikkeli",
        "Kemi",
        "Lappeenranta",
        "Porvoo",
        "Espoo",
        "Vantaa",
        "Hämeenlinna",
        "Kotka",
      ];

      // Train types and their numbers
      const trainTypes = [
        { type: "Long-distance", prefix: "IC", minNumber: 1, maxNumber: 180 },
        { type: "Long-distance", prefix: "S", minNumber: 1, maxNumber: 220 },
        { type: "Commuter", prefix: "R", minNumber: 1, maxNumber: 200 },
        { type: "Commuter", prefix: "Z", minNumber: 1, maxNumber: 100 },
        { type: "Cargo", prefix: "T", minNumber: 1000, maxNumber: 9999 },
        { type: "Locomotive", prefix: "VR", minNumber: 1, maxNumber: 999 },
      ];

      // Create train icon with specified color - more detailed and realistic
      function createTrainIcon(color) {
        return L.divIcon({
          html: `<svg width="28" height="28" viewBox="0 0 100 100">
                <!-- Train body with gradient and shadow -->
                <defs>
                  <linearGradient id="train-gradient-${color.replace(
                    "#",
                    ""
                  )}" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:${color}; stop-opacity:1" />
                    <stop offset="100%" style="stop-color:${adjustColor(
                      color,
                      -30
                    )}; stop-opacity:1" />
                  </linearGradient>
                  <filter id="shadow-${color.replace(
                    "#",
                    ""
                  )}" x="-20%" y="-20%" width="140%" height="140%">
                    <feDropShadow dx="2" dy="2" stdDeviation="2" flood-color="#000" flood-opacity="0.3" />
                  </filter>
                </defs>
                <!-- Main train body -->
                <rect x="20" y="20" width="60" height="60" rx="10" fill="url(#train-gradient-${color.replace(
                  "#",
                  ""
                )})" 
                  stroke="black" stroke-width="1.5" filter="url(#shadow-${color.replace(
                    "#",
                    ""
                  )})" />
                <!-- Train front -->
                <rect x="30" y="15" width="40" height="10" rx="5" fill="url(#train-gradient-${color.replace(
                  "#",
                  ""
                )})" 
                  stroke="black" stroke-width="1.5" />
                <!-- Windows -->
                <rect x="30" y="30" width="12" height="10" rx="2" fill="#d0e6ff" stroke="black" stroke-width="0.7" />
                <rect x="48" y="30" width="12" height="10" rx="2" fill="#d0e6ff" stroke="black" stroke-width="0.7" />
                <rect x="30" y="45" width="12" height="10" rx="2" fill="#d0e6ff" stroke="black" stroke-width="0.7" />
                <rect x="48" y="45" width="12" height="10" rx="2" fill="#d0e6ff" stroke="black" stroke-width="0.7" />
                <!-- Train details -->
                <rect x="35" y="65" width="30" height="3" fill="#e0e0e0" />
                <!-- Wheels -->
                <circle cx="35" cy="83" r="5" fill="#333" stroke="#111" stroke-width="1" />
                <circle cx="65" cy="83" r="5" fill="#333" stroke="#111" stroke-width="1" />
                <circle cx="35" cy="83" r="2" fill="#666" />
                <circle cx="65" cy="83" r="2" fill="#666" />
               </svg>`,
          className: "train-icon",
          iconSize: [28, 28],
          iconAnchor: [14, 14],
        });
      }

      // Helper function to darken/lighten colors
      function adjustColor(color, amount) {
        // Remove # if present
        color = color.replace(/^#/, "");

        // Parse the color
        let r = parseInt(color.substring(0, 2), 16);
        let g = parseInt(color.substring(2, 4), 16);
        let b = parseInt(color.substring(4, 6), 16);

        // Adjust the color
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));

        // Convert back to hex
        return `#${r.toString(16).padStart(2, "0")}${g
          .toString(16)
          .padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      }

      // Start tracking button
      startTrackingButton.addEventListener("click", () => {
        isTracking = true;
        startTrackingButton.style.display = "none";
        stopTrackingButton.style.display = "inline-block";
        statusIndicator.className = "status-indicator active";
        statusText.textContent = "Simulation running";

        // If tracking was paused, restart it
        updateTrains();

        // Add animation effect
        statusIndicator.animate(
          [
            { boxShadow: "0 0 0 0 rgba(0, 204, 0, 0.7)" },
            { boxShadow: "0 0 0 10px rgba(0, 204, 0, 0)" },
            { boxShadow: "0 0 0 0 rgba(0, 204, 0, 0)" },
          ],
          {
            duration: 2000,
            iterations: 3,
          }
        );
      });

      // Stop tracking button
      stopTrackingButton.addEventListener("click", () => {
        isTracking = false;
        stopTrackingButton.style.display = "none";
        startTrackingButton.style.display = "inline-block";
        statusIndicator.className = "status-indicator";
        statusText.textContent = "Tracking paused";

        // Add animation effect
        statusIndicator.animate(
          [{ backgroundColor: "#00cc00" }, { backgroundColor: "#cccccc" }],
          {
            duration: 500,
            iterations: 1,
            fill: "forwards",
          }
        );
      });

      // Toggle settings panel
      toggleSettingsButton.addEventListener("click", () => {
        settingsPanel.style.display =
          settingsPanel.style.display === "none" ? "block" : "none";
      });

      // Update interval display
      updateIntervalInput.addEventListener("input", () => {
        const seconds = updateIntervalInput.value / 1000;
        updateIntervalValue.textContent =
          seconds === 1 ? "1 second" : `${seconds} seconds`;
      });

      // Apply settings
      applySettingsButton.addEventListener("click", () => {
        settings.trainCount = parseInt(trainCountInput.value);
        settings.minSpeed = parseInt(minSpeedInput.value);
        settings.maxSpeed = parseInt(maxSpeedInput.value);
        settings.updateInterval = parseInt(updateIntervalInput.value);

        // Adjust number of trains
        if (Object.keys(trains).length < settings.trainCount) {
          // Add more trains
          const trainsToAdd = settings.trainCount - Object.keys(trains).length;
          createTrains(trainsToAdd);
        } else if (Object.keys(trains).length > settings.trainCount) {
          // Remove excess trains
          const trainsToRemove =
            Object.keys(trains).length - settings.trainCount;
          const trainIds = Object.keys(trains);
          for (let i = 0; i < trainsToRemove; i++) {
            const trainId = trainIds[i];
            map.removeLayer(trains[trainId].marker);
            delete trains[trainId];
          }
        }

        statusText.textContent = "Settings applied";
        setTimeout(() => {
          statusText.textContent = isTracking ? "Simulation running" : "Paused";
        }, 2000);

        updateInfoPanel();
      });

      // Reset trains
      resetTrainsButton.addEventListener("click", () => {
        // Remove all trains
        for (const trainId in trains) {
          map.removeLayer(trains[trainId].marker);
          delete trains[trainId];
        }

        // Create new trains
        createTrains(settings.trainCount);

        statusText.textContent = "Trains reset";
        setTimeout(() => {
          statusText.textContent = isTracking ? "Simulation running" : "Paused";
        }, 2000);
      });

      // Random number within range (inclusive)
      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Random element from array
      function randomElement(array) {
        return array[Math.floor(Math.random() * array.length)];
      }

      // Format time
      function formatTime(timestamp) {
        if (!timestamp) return "N/A";
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
      }
      // Create a random train
      function createRandomTrain() {
        // Random train type and number
        const trainTypeInfo = randomElement(trainTypes);
        const trainType = trainTypeInfo.type;
        const trainNumber = `${trainTypeInfo.prefix}${randomInt(
          trainTypeInfo.minNumber,
          trainTypeInfo.maxNumber
        )}`;

        // Random route
        const route = randomElement(routes);

        // Random starting position along the route
        const pathLength = route.path.length;
        const startSegment = randomInt(0, pathLength - 2);

        // Calculate segment details (current and next points)
        const segmentStart = route.path[startSegment];
        const segmentEnd = route.path[startSegment + 1];

        // Random progress along segment (0-1)
        const segmentProgress = Math.random();

        // Calculate current position
        const lat =
          segmentStart[0] + (segmentEnd[0] - segmentStart[0]) * segmentProgress;
        const lng =
          segmentStart[1] + (segmentEnd[1] - segmentStart[1]) * segmentProgress;

        // Random speed (within settings range)
        const speed = randomInt(settings.minSpeed, settings.maxSpeed);

        // Get icon for train type
        const icon = trainIcons[trainType];

        // Create marker
        const marker = L.marker([lat, lng], { icon: icon }).addTo(map);

        // Generate two random stations for departure/destination
        const departureStation = randomElement(stationNames);
        let destinationStation = randomElement(stationNames);
        // Make sure departure and destination are different
        while (destinationStation === departureStation) {
          destinationStation = randomElement(stationNames);
        }

        // Add popup
        marker.bindPopup(`
        <b>${trainType} Train ${trainNumber}</b><br>
        From: ${departureStation}<br>
        To: ${destinationStation}<br>
        Speed: ${speed} km/h
      `);

        // Determine travel direction (forward/backward)
        const direction = Math.random() > 0.5 ? 1 : -1;

        // Store train data
        const trainId = `train_${Date.now()}_${Math.random()
          .toString(36)
          .substring(2, 10)}`;
        trains[trainId] = {
          id: trainId,
          type: trainType,
          number: trainNumber,
          marker: marker,
          speed: speed,
          departure: departureStation,
          destination: destinationStation,
          route: route,
          currentSegment: startSegment,
          segmentProgress: segmentProgress,
          direction: direction,
          lastSeen: formatTime(new Date()),
        };

        return trainId;
      }

      // Create multiple trains
      function createTrains(count) {
        // Clear existing trains first
        for (const trainId in trains) {
          map.removeLayer(trains[trainId].marker);
          delete trains[trainId];
        }

        // Create new trains
        for (let i = 0; i < count; i++) {
          createRandomTrain();
        }
        updateInfoPanel();

        // Reset chart data
        chartLabels = [];
        trainCounts = {};
        trainSpeeds = {};

        // Update chart
        updateChart();
      }

      // Update info panel with active trains
      function updateInfoPanel() {
        const trainArray = Object.values(trains);

        // Sort trains by type and number
        trainArray.sort((a, b) => {
          if (a.type !== b.type) return a.type.localeCompare(b.type);
          return a.number.localeCompare(b.number, undefined, { numeric: true });
        });

        // Build HTML
        let html = "";
        for (const train of trainArray) {
          html += `
          <div class="train-info">
            <div class="train-type">${train.type} ${train.number}</div>
            <div>${train.departure} → ${train.destination}</div>
            <div class="stats">
              Speed: ${train.speed} km/h | Route: ${train.route.name}
            </div>
            <div class="stats">
              Last updated: ${train.lastSeen}
            </div>
          </div>
        `;
        }

        trainList.innerHTML = html;
        trainCountEl.textContent = `${trainArray.length} trains`;
      }
      // Calculate new position based on speed, time and route
      function updateTrainPosition(train, deltaTime) {
        // Convert km/h to degrees/millisecond (very rough approximation)
        // 100 km/h ≈ 0.00001 degrees per millisecond
        const speedFactor = 0.0000001 * train.speed;

        // Calculate distance to move
        const distance = speedFactor * deltaTime;

        // Get current route segment
        const route = train.route;
        const path = route.path;
        let currentSegment = train.currentSegment;
        let segmentProgress = train.segmentProgress;

        // Get segment points
        const segmentStart = path[currentSegment];
        const segmentEnd = path[currentSegment + train.direction];

        // If next segment doesn't exist, reverse direction
        if (!segmentEnd) {
          train.direction *= -1;

          // Make sure we're still within bounds after direction change
          train.currentSegment = Math.max(
            0,
            Math.min(path.length - 2, train.currentSegment)
          );

          // Get the new segment points after direction change
          const newSegmentStart = path[train.currentSegment];
          const newSegmentEnd = path[train.currentSegment + train.direction];

          // If we still don't have valid segments, skip this update
          if (!newSegmentStart || !newSegmentEnd) {
            return;
          }

          return updateTrainPosition(train, deltaTime);
        }

        // Calculate segment length (very rough approximation)
        const segmentLength = Math.sqrt(
          Math.pow(segmentEnd[0] - segmentStart[0], 2) +
            Math.pow(segmentEnd[1] - segmentStart[1], 2)
        );

        // Calculate new progress along segment
        const newProgress =
          segmentProgress + (distance / segmentLength) * train.direction;

        // Check if we've moved to next segment
        if (newProgress >= 1) {
          // Move to next segment
          train.currentSegment += train.direction;
          train.segmentProgress = newProgress - 1;

          // Check if we've reached the end of the route
          if (
            train.currentSegment >= path.length - 1 ||
            train.currentSegment < 0
          ) {
            train.direction *= -1;
            train.currentSegment = Math.max(
              0,
              Math.min(path.length - 2, train.currentSegment)
            );
          }
        } else if (newProgress < 0) {
          // Move to previous segment
          train.currentSegment += train.direction;
          train.segmentProgress = 1 + newProgress;

          // Check if we've reached the start of the route
          if (
            train.currentSegment >= path.length - 1 ||
            train.currentSegment < 0
          ) {
            train.direction *= -1;
            train.currentSegment = Math.max(
              0,
              Math.min(path.length - 2, train.currentSegment)
            );
          }
        } else {
          // Stay on current segment
          train.segmentProgress = newProgress;
        }

        // Recalculate current segment after potential changes
        currentSegment = train.currentSegment;
        segmentProgress = train.segmentProgress;

        // Ensure segment indices are valid
        if (currentSegment < 0 || currentSegment >= path.length - 1) {
          // Reset to a valid segment
          train.currentSegment = Math.max(
            0,
            Math.min(path.length - 2, train.currentSegment)
          );
          currentSegment = train.currentSegment;
        }

        // Calculate new position - with safety checks
        const newSegmentStart = path[currentSegment];
        const nextSegmentIndex =
          currentSegment + (train.direction > 0 ? 1 : -1);

        // Verify next segment index is valid
        if (nextSegmentIndex < 0 || nextSegmentIndex >= path.length) {
          train.direction *= -1;
          return;
        }

        const newSegmentEnd = path[nextSegmentIndex];

        // Safety check to ensure both points exist
        if (!newSegmentStart || !newSegmentEnd) {
          // Skip position update if we don't have valid coordinates
          return;
        }

        const lat =
          newSegmentStart[0] +
          (newSegmentEnd[0] - newSegmentStart[0]) * segmentProgress;
        const lng =
          newSegmentStart[1] +
          (newSegmentEnd[1] - newSegmentStart[1]) * segmentProgress;

        // Update marker position
        train.marker.setLatLng([lat, lng]);
        train.lastSeen = formatTime(new Date());
      }
      // Chart variables
      let myChart = null;
      let chartLabels = [];
      let trainCounts = {};
      let trainSpeeds = {};
      const MAX_DATA_POINTS = 10;

      // Initialize chart
      function initChart() {
        try {
          const ctx = document.getElementById("chartCanvas").getContext("2d");

          // Default datasets for different train types
          const datasets = [
            {
              label: "Long-distance",
              data: [0],
              borderColor: "#ff0000",
              backgroundColor: "rgba(255, 0, 0, 0.2)",
            },
            {
              label: "Commuter",
              data: [0],
              borderColor: "#00aa00",
              backgroundColor: "rgba(0, 170, 0, 0.2)",
            },
            {
              label: "Cargo",
              data: [0],
              borderColor: "#0000ff",
              backgroundColor: "rgba(0, 0, 255, 0.2)",
            },
            {
              label: "Locomotive",
              data: [0],
              borderColor: "#aa00aa",
              backgroundColor: "rgba(170, 0, 170, 0.2)",
            },
            {
              label: "Shunting",
              data: [0],
              borderColor: "#aa6600",
              backgroundColor: "rgba(170, 102, 0, 0.2)",
            },
          ];

          // Create chart
          myChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: ["Start"],
              datasets: datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Speed (km/h)",
                  },
                },
                x: {
                  title: {
                    display: true,
                    text: "Time",
                  },
                },
              },
              animation: {
                duration: 0, // Disable animation for better performance
              },
            },
          });

          // Add initial time
          chartLabels.push(formatTime(new Date()));

          console.log("Chart initialized successfully");
        } catch (error) {
          console.error("Failed to initialize chart:", error);
        }
      }

      // Count trains by type
      function countTrainsByType() {
        const counts = {
          "Long-distance": 0,
          Commuter: 0,
          Cargo: 0,
          Locomotive: 0,
          Shunting: 0,
        };

        for (const trainId in trains) {
          const type = trains[trainId].type;
          counts[type]++;
        }

        return counts;
      }

      // Calculate average speed by type
      function getAverageSpeedByType() {
        const speeds = {
          "Long-distance": [],
          Commuter: [],
          Cargo: [],
          Locomotive: [],
          Shunting: [],
        };

        for (const trainId in trains) {
          const train = trains[trainId];
          speeds[train.type].push(train.speed);
        }

        const avgSpeeds = {};
        for (const type in speeds) {
          const typeSpeedsArray = speeds[type];
          if (typeSpeedsArray.length > 0) {
            const sum = typeSpeedsArray.reduce((acc, val) => acc + val, 0);
            avgSpeeds[type] = sum / typeSpeedsArray.length;
          } else {
            avgSpeeds[type] = 0;
          }
        }

        return avgSpeeds;
      }

      // Update chart based on selected type
      function updateChart() {
        try {
          if (!myChart) {
            initChart();
            return;
          }

          // Add new timestamp
          const now = formatTime(new Date());
          chartLabels.push(now);

          // Limit number of data points
          if (chartLabels.length > MAX_DATA_POINTS) {
            chartLabels.shift();
          }

          // Update data based on chart type
          const chartType = chartTypeSelector.value;

          switch (chartType) {
            case "speed":
              updateSpeedChart();
              break;
            case "count":
              updateCountChart();
              break;
            case "distribution":
              updateDistributionChart();
              break;
          }
        } catch (error) {
          console.error("Error updating chart:", error);
        }
      }

      // Update speed chart
      function updateSpeedChart() {
        // Get average speeds by type
        const avgSpeeds = getAverageSpeedByType();

        // Store for history
        trainSpeeds[chartLabels[chartLabels.length - 1]] = { ...avgSpeeds };

        // Limit history
        if (Object.keys(trainSpeeds).length > MAX_DATA_POINTS) {
          const oldestKey = Object.keys(trainSpeeds)[0];
          delete trainSpeeds[oldestKey];
        }

        // Update datasets
        const newData = {
          labels: chartLabels,
          datasets: [
            {
              label: "Long-distance",
              data: chartLabels.map((label) =>
                trainSpeeds[label] ? trainSpeeds[label]["Long-distance"] : 0
              ),
              borderColor: "#ff0000",
              backgroundColor: "rgba(255, 0, 0, 0.2)",
              tension: 0.1,
            },
            {
              label: "Commuter",
              data: chartLabels.map((label) =>
                trainSpeeds[label] ? trainSpeeds[label]["Commuter"] : 0
              ),
              borderColor: "#00aa00",
              backgroundColor: "rgba(0, 170, 0, 0.2)",
              tension: 0.1,
            },
            {
              label: "Cargo",
              data: chartLabels.map((label) =>
                trainSpeeds[label] ? trainSpeeds[label]["Cargo"] : 0
              ),
              borderColor: "#0000ff",
              backgroundColor: "rgba(0, 0, 255, 0.2)",
              tension: 0.1,
            },
            {
              label: "Locomotive",
              data: chartLabels.map((label) =>
                trainSpeeds[label] ? trainSpeeds[label]["Locomotive"] : 0
              ),
              borderColor: "#aa00aa",
              backgroundColor: "rgba(170, 0, 170, 0.2)",
              tension: 0.1,
            },
            {
              label: "Shunting",
              data: chartLabels.map((label) =>
                trainSpeeds[label] ? trainSpeeds[label]["Shunting"] : 0
              ),
              borderColor: "#aa6600",
              backgroundColor: "rgba(170, 102, 0, 0.2)",
              tension: 0.1,
            },
          ],
        };

        // Update chart
        myChart.data = newData;
        myChart.options.scales.y.title.text = "Average Speed (km/h)";

        // Make sure chart is line type
        if (myChart.config.type !== "line") {
          myChart.destroy();
          const ctx = document.getElementById("chartCanvas").getContext("2d");
          myChart = new Chart(ctx, {
            type: "line",
            data: newData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Average Speed (km/h)",
                  },
                },
                x: {
                  title: {
                    display: true,
                    text: "Time",
                  },
                },
              },
              animation: {
                duration: 0,
              },
            },
          });
        } else {
          myChart.update();
        }
      }
      // Update count chart
      function updateCountChart() {
        // Get counts by type
        const counts = countTrainsByType();

        // Store for history
        trainCounts[chartLabels[chartLabels.length - 1]] = { ...counts };

        // Limit history
        if (Object.keys(trainCounts).length > MAX_DATA_POINTS) {
          const oldestKey = Object.keys(trainCounts)[0];
          delete trainCounts[oldestKey];
        }

        // Update datasets
        const newData = {
          labels: chartLabels,
          datasets: [
            {
              label: "Long-distance",
              data: chartLabels.map((label) =>
                trainCounts[label] ? trainCounts[label]["Long-distance"] : 0
              ),
              borderColor: "#ff0000",
              backgroundColor: "rgba(255, 0, 0, 0.2)",
              fill: true,
              tension: 0.1,
            },
            {
              label: "Commuter",
              data: chartLabels.map((label) =>
                trainCounts[label] ? trainCounts[label]["Commuter"] : 0
              ),
              borderColor: "#00aa00",
              backgroundColor: "rgba(0, 170, 0, 0.2)",
              fill: true,
              tension: 0.1,
            },
            {
              label: "Cargo",
              data: chartLabels.map((label) =>
                trainCounts[label] ? trainCounts[label]["Cargo"] : 0
              ),
              borderColor: "#0000ff",
              backgroundColor: "rgba(0, 0, 255, 0.2)",
              fill: true,
              tension: 0.1,
            },
            {
              label: "Locomotive",
              data: chartLabels.map((label) =>
                trainCounts[label] ? trainCounts[label]["Locomotive"] : 0
              ),
              borderColor: "#aa00aa",
              backgroundColor: "rgba(170, 0, 170, 0.2)",
              fill: true,
              tension: 0.1,
            },
            {
              label: "Shunting",
              data: chartLabels.map((label) =>
                trainCounts[label] ? trainCounts[label]["Shunting"] : 0
              ),
              borderColor: "#aa6600",
              backgroundColor: "rgba(170, 102, 0, 0.2)",
              fill: true,
              tension: 0.1,
            },
          ],
        };

        // Update chart
        myChart.data = newData;
        myChart.options.scales.y.title.text = "Number of Trains";

        // Make sure chart is line type
        if (myChart.config.type !== "line") {
          myChart.destroy();
          const ctx = document.getElementById("chartCanvas").getContext("2d");
          myChart = new Chart(ctx, {
            type: "line",
            data: newData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Number of Trains",
                  },
                },
                x: {
                  title: {
                    display: true,
                    text: "Time",
                  },
                },
              },
              animation: {
                duration: 0,
              },
            },
          });
        } else {
          myChart.update();
        }
      }

      // Update distribution chart
      function updateDistributionChart() {
        // Group trains by speed ranges
        const speedRanges = ["0-40", "41-80", "81-120", "121-160", "160+"];
        const speedData = {
          "Long-distance": [0, 0, 0, 0, 0],
          Commuter: [0, 0, 0, 0, 0],
          Cargo: [0, 0, 0, 0, 0],
          Locomotive: [0, 0, 0, 0, 0],
          Shunting: [0, 0, 0, 0, 0],
        };

        // Count trains in each speed range
        for (const trainId in trains) {
          const train = trains[trainId];
          const speed = train.speed;
          let rangeIndex;

          if (speed <= 40) rangeIndex = 0;
          else if (speed <= 80) rangeIndex = 1;
          else if (speed <= 120) rangeIndex = 2;
          else if (speed <= 160) rangeIndex = 3;
          else rangeIndex = 4;

          speedData[train.type][rangeIndex]++;
        }

        // Create bar chart data
        const barData = {
          labels: speedRanges,
          datasets: [
            {
              label: "Long-distance",
              data: speedData["Long-distance"],
              backgroundColor: "#ff0000",
              borderColor: "rgba(0, 0, 0, 0.1)",
              borderWidth: 1,
            },
            {
              label: "Commuter",
              data: speedData["Commuter"],
              backgroundColor: "#00aa00",
              borderColor: "rgba(0, 0, 0, 0.1)",
              borderWidth: 1,
            },
            {
              label: "Cargo",
              data: speedData["Cargo"],
              backgroundColor: "#0000ff",
              borderColor: "rgba(0, 0, 0, 0.1)",
              borderWidth: 1,
            },
            {
              label: "Locomotive",
              data: speedData["Locomotive"],
              backgroundColor: "#aa00aa",
              borderColor: "rgba(0, 0, 0, 0.1)",
              borderWidth: 1,
            },
            {
              label: "Shunting",
              data: speedData["Shunting"],
              backgroundColor: "#aa6600",
              borderColor: "rgba(0, 0, 0, 0.1)",
              borderWidth: 1,
            },
          ],
        };

        // Check if we need to change chart type
        if (myChart.config.type !== "bar") {
          myChart.destroy();
          const ctx = document.getElementById("chartCanvas").getContext("2d");
          myChart = new Chart(ctx, {
            type: "bar",
            data: barData,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Number of Trains",
                  },
                },
                x: {
                  title: {
                    display: true,
                    text: "Speed Range (km/h)",
                  },
                },
              },
              animation: {
                duration: 0,
              },
            },
          });
        } else {
          myChart.data = barData;
          myChart.options.scales.y.title.text = "Number of Trains";
          myChart.options.scales.x.title.text = "Speed Range (km/h)";
          myChart.update();
        }
      }

      // Chart type change handler
      chartTypeSelector.addEventListener("change", updateChart);

      // Update all trains
      function updateTrains() {
        if (!isTracking) {
          return;
        }

        const now = new Date();
        const deltaTime = lastUpdateTime
          ? now - lastUpdateTime
          : settings.updateInterval;
        lastUpdateTime = now;

        // Update train positions
        for (const trainId in trains) {
          updateTrainPosition(trains[trainId], deltaTime);
        }

        // Update info panel
        updateInfoPanel();

        // Update chart data every 5 updates (reduces overhead)
        if (updateCount % 5 === 0) {
          updateChart();
        }

        updateCount++;
        statusText.textContent = `Simulation running (${updateCount} updates)`;

        // Schedule next update
        setTimeout(updateTrains, settings.updateInterval);
      }

      // Initialization
      function init() {
        // Set input values from settings
        trainCountInput.value = settings.trainCount;
        minSpeedInput.value = settings.minSpeed;
        maxSpeedInput.value = settings.maxSpeed;
        updateIntervalInput.value = settings.updateInterval;

        // Update interval display
        const seconds = settings.updateInterval / 1000;
        updateIntervalValue.textContent =
          seconds === 1 ? "1 second" : `${seconds} seconds`;

        // Initialize tracking buttons
        if (isTracking) {
          startTrackingButton.style.display = "none";
          stopTrackingButton.style.display = "inline-block";
        } else {
          startTrackingButton.style.display = "inline-block";
          stopTrackingButton.style.display = "none";
        }

        // Initialize chart
        initChart();

        // Create initial trains
        createTrains(settings.trainCount);

        // Start updating
        updateTrains();
      }

      // Start the simulation
      init();
    </script>
  </body>
</html>
